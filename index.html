<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Time Stream</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #time-display {
            font-size: 2em;
            margin: 20px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
        }
        #connection-status {
            padding: 5px 10px;
            border-radius: 3px;
            margin-bottom: 20px;
        }
        .connected { background: #cfc; }
        .disconnected { background: #fcc; }
        .connecting { background: #ffc; }
        #track-timer {
            font-size: 1.5em;
            margin: 20px 0;
            padding: 10px;
            background: #e0e0ff;
            border-radius: 5px;
        }
        #track-info {
            font-size: 1em;
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Radio Automation Monitor</h1>

    <div>
        Connection status: <span id="connection-status" class="connecting">Connecting...</span>
    </div>

    <div id="time-display">Waiting for connection...</div>
    
    <div id="track-info">No track playing</div>
    <div id="track-timer">--:--</div>

    <script>
        const statusEl = document.getElementById('connection-status');
        const timeEl = document.getElementById('time-display');
        const trackTimerEl = document.getElementById('track-timer');
        const trackInfoEl = document.getElementById('track-info');
        let lastMessage = '';
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 3000; // 3 seconds
        let countdownInterval = null;
        let currentCountdown = 0;
        let lastTrackData = null;

        // Format JSON for nice console output
        function formatForConsole(data) {
            console.groupCollapsed('WebSocket Message Received');
            console.log('Timestamp:', new Date().toISOString());
            console.log('Status:', data.status || 'Unknown');
            console.log('Full Data:', data);
            console.groupEnd();
            
            // Alternative formatted output
            console.log('%cWebSocket Data:', 'color: #4CAF50; font-weight: bold', 
                JSON.stringify(data, null, 2));
        }

        // Format seconds to MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(Math.abs(seconds) / 60);
            const secs = Math.floor(Math.abs(seconds) % 60);
            const sign = seconds < 0 ? '-' : '';
            return `${sign}${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Start or update the countdown timer
        function updateCountdown(data) {
            // Clear any existing interval
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            // Extract filename from track path
            const filename = data.track.split('/').pop();
            
            if (data.status === 'start') {
                trackInfoEl.textContent = `Now playing: ${filename}`;
                currentCountdown = data.file_duration;
                trackTimerEl.textContent = formatTime(currentCountdown);
                
                // Start countdown from file_duration
                countdownInterval = setInterval(() => {
                    currentCountdown -= 1;
                    trackTimerEl.textContent = formatTime(currentCountdown);
                    
                    if (currentCountdown <= 0) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                }, 1000);
                
            } else if (data.status === 'playing') {
                trackInfoEl.textContent = `Now playing: ${filename}`;
                currentCountdown = data.remaining_time;
                trackTimerEl.textContent = formatTime(currentCountdown);
                
                // Start countdown from remaining_time
                countdownInterval = setInterval(() => {
                    currentCountdown -= 1;
                    trackTimerEl.textContent = formatTime(currentCountdown);
                    
                    if (currentCountdown <= 0) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                }, 1000);
            } else {
                // For other statuses, just display the track info without countdown
                trackInfoEl.textContent = `Track info: ${filename}`;
                trackTimerEl.textContent = '--:--';
            }
            
            lastTrackData = data;
        }

        // WebSocket connection management
        function connectWebSocket() {
            const ws = new WebSocket('wss://zaracloud.kaboutersoft.be/ws');
            statusEl.textContent = 'Connecting...';
            statusEl.className = 'connecting';

            ws.onopen = () => {
                statusEl.textContent = 'Connected';
                statusEl.className = 'connected';
                timeEl.textContent = 'Waiting for first update...';
                reconnectAttempts = 0;
                console.log('%cWebSocket Connected', 'color: green; font-weight: bold');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    formatForConsole(data); // Log to console
                    updateTime(data);
                    
                    // Update countdown if we have track data
                    if (data.status === 'start' || data.status === 'playing') {
                        updateCountdown(data);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                    console.log('Raw message:', event.data);
                }
            };

            ws.onclose = (event) => {
                statusEl.textContent = 'Disconnected';
                statusEl.className = 'disconnected';
                console.log('%cWebSocket Disconnected', 'color: orange; font-weight: bold', event);

                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    timeEl.textContent = `Reconnecting in ${reconnectDelay/1000} seconds (attempt ${reconnectAttempts}/${maxReconnectAttempts})...`;
                    setTimeout(connectWebSocket, reconnectDelay);
                } else {
                    timeEl.textContent = 'Connection failed. Please refresh the page.';
                    console.error('Max reconnection attempts reached');
                }
                
                // Clear the countdown when disconnected
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                trackTimerEl.textContent = '--:-- (disconnected)';
            };

            ws.onerror = (error) => {
                console.error('%cWebSocket Error:', 'color: red; font-weight: bold', error);
                statusEl.textContent = 'Connection error';
            };

            return ws;
        }

        // Update UI with new data
        function updateTime(data) {
            const date = new Date(data.utc * 1000);

            if (data.messages) {
                lastMessage = data.messages;
            }

            timeEl.innerHTML = `
                ${lastMessage ? `message: ${lastMessage}<br>` : ''}
                Server Time: ${data.iso}<br>
                Local Time: ${date.toLocaleString()}<br>
                Unix Timestamp: ${data.utc}
            `;
        }

        // Initialize connection when page loads
        window.addEventListener('DOMContentLoaded', () => {
            console.log('%cInitializing WebSocket Connection...', 'color: blue; font-weight: bold');
            connectWebSocket();
        });
    </script>
</body>
</html>
